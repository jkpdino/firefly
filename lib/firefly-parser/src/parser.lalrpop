use firefly_ast::{
    Visibility,
    Path, PathSegment,
    ty::Ty,
    value::{Value, IfStatement, ElseStatement, WhileStatement},
    stmt::{Stmt, CodeBlock},
    func::{Func, FuncParam},
    item::Item,
    struct_def::{StructDef, Field},
    module::Module,
    import::{Import, ImportSymbolList, ImportSymbol}
};
use crate::{
    error::{LexerError, ParserErrorEnv, Expecting},
    lexer::Token,
};
use firefly_span::{
    BytePos,
    Span,
    Spanned
};

grammar<'source, 'env>(
    errors: &'env ParserErrorEnv<'source>
);

extern {
    type Location = BytePos;
    type Error = (LexerError, Span);
    enum Token<'source> {
        "ident" => Token::Ident(<&'source str>),

        "public" => Token::PublicKw,
        "internal" => Token::InternalKw,
        "fileprivate" => Token::FilePrivateKw,
        "private" => Token::PrivateKw,

        "static" => Token::StaticKw,

        "module" => Token::ModuleKw,
        "import" => Token::ImportKw,

        "as" => Token::AsKw,

        "var" => Token::VarKw,
        "struct" => Token::StructKw,
        "func" => Token::FuncKw,

        "static" => Token::StaticKw,

        "return" => Token::ReturnKw,
        "if" => Token::IfKw,
        "else" => Token::ElseKw,
        "while" => Token::WhileKw,

        "integer" => Token::IntegerLiteral(<&'source str>),
        "string" => Token::StringLiteral(<&'source str>),
        "long_string" => Token::LongStringLiteral(<&'source str>),

        // Symbols
        "(" => Token::OpenParen,
        ")" => Token::CloseParen,
        "{" => Token::OpenBrace,
        "}" => Token::CloseBrace,

        "." => Token::Period,
        "," => Token::Comma,
        ";" => Token::Semicolon,
        ":" => Token::Colon,
        "->" => Token::Arrow,

        "=" => Token::Equals,

        "whitespace" => Token::Whitespace,
    }
}

pub Top = { Item* }

Item: Item = {
    <Struct> => Item::StructDef(<>),
    <Function> => Item::Func(<>),
    <Field> => Item::Field(<>),
    <Module> => Item::Module(<>),
    <Import> => Item::Import(<>),

    ExpectItem => Item::Error
}

// Modules
Module = { Spanned<UnspannedModule> }
UnspannedModule: Module = {
    "module" <path: Path> ";"? => Module {
        path
    },
}

// Imports

Import = { Spanned<UnspannedImport> };
UnspannedImport: Import = {
    "import" <module: Path> <alias: Rename?> <symbol_list: ImportSymbolList?> ";"? => Import::new(
        module,
        alias,
        symbol_list
    ),
}

ImportSymbolList: ImportSymbolList = {
    "(" <symbols: CommaList<ImportSymbol>> ")" => ImportSymbolList { symbols }
}

ImportSymbol: ImportSymbol = {
    <name: Name> <alias: Rename?> => ImportSymbol { name, alias }
}

Rename: Spanned<String> = {
    "as" <name: Name> => name
}

// Structs

Field = { Spanned<UnspannedField> }
UnspannedField: Field = {
    <visibility: Visibility?> <static_kw: StaticKw?> "var" <name: Name> ":" <ty: Type> <default: EqualsValue?> ";"? => Field::new(
        visibility,
        static_kw,
        name,
        ty,
        default,
    )
}

Struct = { Spanned<UnspannedStruct> }
UnspannedStruct: StructDef = {
    <visibility: Visibility?> "struct" <name: Name> "{" <items: Item*> "}" => StructDef::new(
        visibility,
        name,
        items,
    )
}

EqualsValue: Spanned<Value> = {
    "=" <value: Value> => value
}

// Function
FuncParam: Spanned<FuncParam> = {
    <l: @L> <name: Name> ":" <ty: Type> <r: @R> => Spanned::new(FuncParam::new(name, ty), Span::new(l, r))
}

Function = { Spanned<UnspannedFunction> }
UnspannedFunction: Func = {
    <visibility: Visibility?> <static_kw: StaticKw?> "func" <name: Name> "(" <params: CommaList<FuncParam>> ")" <return_ty:ReturnType?> <body: CodeBlock> => Func::new(
        visibility,
        static_kw,
        name,
        params,
        return_ty,
        body,
    )
}

ReturnType: Spanned<Ty> = {
    "->" <return_ty:Type> => return_ty,
}

// Statements
BindStmt: Stmt = {
    "var" <name: Name> ":" <ty: Type> "=" <value: Value> => Stmt::Bind(name, ty, value)
}

Stmt = { Spanned<UnspannedStmt> }
UnspannedStmt: Stmt = {
    <Value> => Stmt::Value(<>),
    <BindStmt> => <>,
}

Stmts: Vec<Spanned<Stmt>> = {
    <mut v:(<Stmt> ";")*> <e:Stmt?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
}

CodeBlock: CodeBlock = {
    "{" <stmts: Stmts> "}" => CodeBlock::new(stmts)
}

// Values
Value = { Spanned<UnspannedValue> }
UnspannedValue: Value = {
    FlowExpr => <>
}

FlowExpr: Value = {
    TrailingExpr => <>,
    IfStatement => Value::If(Box::new(<>)),
    WhileStatement => Value::While(Box::new(<>)),
    "return" <value: Value?> => Value::Return(value.map(Box::new))
}

TrailingExpr: Value = {
    AtomExpr => <>,
    <func: Spanned<AtomExpr>> "(" <args: CommaList<Value>> ")" => Value::Call(Box::new(func), args),
}

AtomExpr: Value = {
    LiteralValue => <>,
    "(" <items: CommaList<Value>> ")" => Value::Tuple(items),
    <Path> => Value::Path(<>),
}

LiteralValue: Value = {
    Spanned<"integer"> => Value::IntegerLiteral(Spanned::new(<>.item.into(), <>.span)),
    Spanned<"string"> => Value::StringLiteral(Spanned::new(<>.item.into(), <>.span)),
    Spanned<"long_string"> => Value::StringLiteral(Spanned::new(<>.item.into(), <>.span)),
}

IfStatement: IfStatement = {
    "if" <condition: Value> <positive: CodeBlock> <negative: ElseStatement?> => IfStatement {
        condition,
        positive,
        negative,
    }
}

WhileStatement: WhileStatement = {
    "while" <condition: Value> <body: CodeBlock> => WhileStatement {
        label: None,
        condition,
        body
    },
    <label: Name> ":" "while" <condition: Value> <body: CodeBlock> => WhileStatement {
        label: Some(label),
        condition,
        body
    }
}

ElseStatement: ElseStatement = {
    "else" <negative: CodeBlock> => ElseStatement::Else(negative),
    "else" <negative: IfStatement> => ElseStatement::ElseIf(Box::new(negative)),
}

// Types
Type = { Spanned<UnspannedType> }
UnspannedType: Ty = {
    "(" <items: CommaList<Type>> ")" => Ty::Tuple(items),
    <Path> => Ty::Path(<>),

    ExpectType => Ty::Error,
}


// Common
Path: Path = {
    <s: Spanned<PathSegments>> => Path::new(s.item, s.span)
}

PathSegments: Vec<PathSegment> = {
    <s: PathSegment> => vec![s],
    <mut v: PathSegments> "." <s: PathSegment> => {
        v.push(s);
        v
    },
    <v: PathSegments> "." Recover => vec![],
}

PathSegment: PathSegment = {
    <i: Name> => PathSegment::new(i)
}

Visibility = { Spanned<UnspannedVisibility> }
UnspannedVisibility: Visibility = {
    "public" => Visibility::Public,
    "internal" => Visibility::Internal,
    "fileprivate" => Visibility::FilePrivate,
    "private" => Visibility::Private
}

// Util
Spanned<T>: Spanned<T> = {
    <l: @L> <t: T> <r: @R> => Spanned::new(t, Span::new(l, r))
}

#[inline]
CommaList<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
}

Name: Spanned<String> = {
    Spanned<"ident"> => Spanned::new(<>.item.into(), <>.span)
}

// Keywords
StaticKw: Span = {
    Spanned<"static"> => <>.span
}


// Error Handling

#[inline]
Recover: () = {
    ! => {
        errors.emit(<>.error, None);
    }
}

#[inline]
ExpectItem: () = {
    ! => {
        errors.emit(<>.error, Some(Expecting::Item));
    }
}

#[inline]
ExpectType: () = {
    ! => {
        errors.emit(<>.error, Some(Expecting::Type));
    }
}

#[inline]
ExpectValue: () = {
    ! => {
        errors.emit(<>.error, Some(Expecting::Value));
    }
}

#[inline]
ExpectStmt: () = {
    ! => {
        errors.emit(<>.error, Some(Expecting::Stmt));
    }
}

#[inline]
ExpectPath: () = {
    ! => {
        errors.emit(<>.error, Some(Expecting::Path));
    }
}