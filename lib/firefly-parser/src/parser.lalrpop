use firefly_ast::{
    Visibility,
    Path, PathSegment,
    ty::Ty,
    value::Value,
    stmt::{Stmt, CodeBlock},
    func::{Func, FuncParam},
    item::Item,
    struct_def::{StructDef, Field},
    module::Module,
    import::{Import, ImportSymbolList, ImportSymbol}
};
use crate::{
    error::LexerError,
    lexer::Token,
};
use firefly_span::{
    BytePos,
    Span,
    Spanned
};

grammar<'source>;

extern {
    type Location = BytePos;
    type Error = LexerError;
    enum Token<'source> {
        "ident" => Token::Ident(<&'source str>),

        "public" => Token::PublicKw,
        "internal" => Token::InternalKw,
        "fileprivate" => Token::FilePrivateKw,
        "private" => Token::PrivateKw,

        "module" => Token::ModuleKw,
        "import" => Token::ImportKw,

        "struct" => Token::StructKw,
        "func" => Token::FuncKw,
        "init" => Token::InitKw,

        "var" => Token::VarKw,

        "return" => Token::ReturnKw,

        "as" => Token::AsKw,

        "integer" => Token::IntegerLiteral(<&'source str>),

        // Symbols
        "(" => Token::OpenParen,
        ")" => Token::CloseParen,
        "{" => Token::OpenBrace,
        "}" => Token::CloseBrace,

        "." => Token::Period,
        "," => Token::Comma,
        ";" => Token::Semicolon,
        ":" => Token::Colon,
        "->" => Token::Arrow,

        "=" => Token::Equals,

        "whitespace" => Token::Whitespace,
    }
}

pub Top = { Item* }

Item: Item = {
    <Struct> => Item::StructDef(<>),
    <Function> => Item::Func(<>),
    <Field> => Item::Field(<>),
    <Module> => Item::Module(<>),
    <Import> => Item::Import(<>),
}

// Modules
Module = { Spanned<UnspannedModule> }
UnspannedModule: Module = {
    "module" <path: Path> ";"? => Module {
        path
    }
}

// Imports

Import = { Spanned<UnspannedImport> };
UnspannedImport: Import = {
    "import" <module: Path> <alias: Rename?> <symbol_list: ImportSymbolList?> ";"? => Import::new(
        module,
        alias,
        symbol_list
    )
}

ImportSymbolList: ImportSymbolList = {
    "(" <symbols: CommaList<ImportSymbol>> ")" => ImportSymbolList { symbols }
}

ImportSymbol: ImportSymbol = {
    <name: Name> <alias: Rename?> => ImportSymbol { name, alias }
}

Rename: Spanned<String> = {
    "as" <name: Name> => name
}

// Structs

Field = { Spanned<UnspannedField> }
UnspannedField: Field = {
    <visibility: Visibility?> "var" <name: Name> ":" <ty: Type> => Field {
        visibility,
        name,
        ty,
    }
}

Struct = { Spanned<UnspannedStruct> }
UnspannedStruct: StructDef = {
    <visibility: Visibility?> "struct" <name: Name> "{" <items: Item*> "}" => StructDef::new(
        visibility,
        name,
        items,
    )
}

// Function
FuncParam: Spanned<FuncParam> = {
    <l: @L> <name: Name> ":" <ty: Type> <r: @R> => Spanned::new(FuncParam::new(name, ty), Span::new(l, r))
}

Function = { Spanned<UnspannedFunction> }
UnspannedFunction: Func = {
    <visibility: Visibility?> "func" <name: Name> "(" <params: CommaList<FuncParam>> ")" <return_ty:ReturnType?> <body: CodeBlock> => Func::new(
        visibility,
        name,
        params,
        return_ty,
        body,
    )
}

ReturnType: Spanned<Ty> = {
    "->" <return_ty:Type> => return_ty,
}

// Statements
BindStmt: Stmt = {
    "var" <name: Name> ":" <ty: Type> "=" <value: Value> => Stmt::Bind(name, ty, value)
}

Stmt = { Spanned<UnspannedStmt> }
UnspannedStmt: Stmt = {
    <Value> => Stmt::Value(<>),
    <BindStmt> => <>
}

Stmts: Vec<Spanned<Stmt>> = {
    <mut v:(<Stmt> ";")*> <e:Stmt?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
}

CodeBlock: CodeBlock = {
    "{" <stmts: Stmts> "}" => CodeBlock::new(stmts)
}

// Values
Value = { Spanned<UnspannedValue> }
UnspannedValue: Value = {
    "(" <items: CommaList<Value>> ")" => Value::Tuple(items),
    Spanned<"integer"> => Value::IntegerLiteral(Spanned::new(<>.item.into(), <>.span)),
    <func: Value> "(" <args: CommaList<Value>> ")" => Value::Call(Box::new(func), args),
    <Path> => Value::Path(<>),
}

// Types
Type = { Spanned<UnspannedType> }
UnspannedType: Ty = {
    "(" <items: CommaList<Type>> ")" => Ty::Tuple(items),
    <Path> => Ty::Path(<>)
}


// Common
Path: Path = {
    <s: Spanned<PathSegments>> => Path::new(s.item, s.span)
}

PathSegments: Vec<PathSegment> = {
    <s: PathSegment> => vec![s],
    <mut v: PathSegments> "." <s: PathSegment> => {
        v.push(s);
        v
    }
}

PathSegment: PathSegment = {
    <i: Name> => PathSegment::new(i)
}

Visibility = { Spanned<UnspannedVisibility> }
UnspannedVisibility: Visibility = {
    "public" => Visibility::Public,
    "internal" => Visibility::Internal,
    "fileprivate" => Visibility::FilePrivate,
    "private" => Visibility::Private
}

// Util

Spanned<T>: Spanned<T> = {
    <l: @L> <t: T> <r: @R> => Spanned::new(t, Span::new(l, r))
}

#[inline]
CommaList<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
}

Name: Spanned<String> = {
    Spanned<"ident"> => Spanned::new(<>.item.into(), <>.span)
}
